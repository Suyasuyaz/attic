name: Close Parent Issue When All Child Issues Are Closed

on:
  issues:
    types: [closed]
  workflow_dispatch:

jobs:
  check-and-close-parent-issues:
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '16'
          
      - name: Close Parent Issue
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issueNumber = context.payload.issue ? context.payload.issue.number : null;
            
            // ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ãŒæ‰‹å‹•å®Ÿè¡Œã•ã‚ŒãŸå ´åˆã¯ã™ã¹ã¦ã®è¦ªIssueã‚’ãƒã‚§ãƒƒã‚¯
            if (!issueNumber) {
              console.log('Workflow triggered manually. Checking all possible parent issues...');
              await checkAllParentIssues();
            } else {
              console.log(`Issue #${issueNumber} was closed. Checking for parent issues...`);
              await findAndCheckParentIssues(issueNumber);
            }
            
            // é–‰ã˜ã‚‰ã‚ŒãŸIssueã®è¦ªIssueã‚’æ¢ã—ã¦å‡¦ç†ã™ã‚‹é–¢æ•°
            async function findAndCheckParentIssues(childIssueNumber) {
              // GitHub Issueã®æœ¬æ–‡ã‚„ã‚³ãƒ¡ãƒ³ãƒˆã‹ã‚‰è¦ªIssueã¸ã®å‚ç…§ã‚’æ¤œç´¢
              const childIssue = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: childIssueNumber
              });
              
              // è¦ªIssueã¸ã®å‚ç…§ã‚’æ¤œç´¢ï¼ˆ"parent of #xx" å½¢å¼ã‚„ "closes #xx" å½¢å¼ãªã©ï¼‰
              const bodyText = childIssue.data.body || '';
              const parentMatches = bodyText.match(/(?:part of|parent:|related to) #(\d+)/gi);
              
              if (parentMatches && parentMatches.length > 0) {
                for (const match of parentMatches) {
                  const matchResult = match.match(/#(\d+)/);
                  if (matchResult && matchResult[1]) {
                    const parentIssueNumber = parseInt(matchResult[1]);
                    console.log(`Found potential parent issue #${parentIssueNumber}`);
                    await checkIfAllChildrenClosed(parentIssueNumber);
                  }
                }
              } else {
                console.log(`No parent reference found in issue #${childIssueNumber}`);
              }
            }
            
            // ã™ã¹ã¦ã®è¦ªIssueã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹é–¢æ•°ï¼ˆæ‰‹å‹•å®Ÿè¡Œç”¨ï¼‰
            async function checkAllParentIssues() {
              // ã‚ªãƒ¼ãƒ—ãƒ³ã—ã¦ã„ã‚‹å…¨Issueã‚’å–å¾—
              const { data: openIssues } = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                per_page: 100
              });
              
              for (const issue of openIssues) {
                // Issueã®æœ¬æ–‡ã«å­Issueã¸ã®å‚ç…§ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                const bodyText = issue.body || '';
                if (bodyText.match(/(?:child of|children:|sub-task:|sub task:)/i)) {
                  console.log(`Checking parent issue #${issue.number}`);
                  await checkIfAllChildrenClosed(issue.number);
                }
              }
            }
            
            // è¦ªIssueã®ã™ã¹ã¦ã®å­IssueãŒã‚¯ãƒ­ãƒ¼ã‚ºã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ã™ã‚‹é–¢æ•°
            async function checkIfAllChildrenClosed(parentIssueNumber) {
              try {
                // è¦ªIssueã®æƒ…å ±ã‚’å–å¾—
                const parentIssue = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: parentIssueNumber
                });
                
                if (parentIssue.data.state === 'closed') {
                  console.log(`Parent issue #${parentIssueNumber} is already closed.`);
                  return;
                }
                
                // è¦ªIssueã®æœ¬æ–‡ã‹ã‚‰å­Issueã¸ã®å‚ç…§ã‚’æ¤œç´¢
                const bodyText = parentIssue.data.body || '';
                const childMatches = bodyText.match(/(?:child|sub-task|subtask|todo).*?#(\d+)/gi);
                
                if (!childMatches || childMatches.length === 0) {
                  console.log(`No child issues found for #${parentIssueNumber}`);
                  return;
                }
                
                // å„å­Issueã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ãƒã‚§ãƒƒã‚¯
                let allClosed = true;
                let closedIssues = [];
                
                for (const match of childMatches) {
                  const numberMatch = match.match(/#(\d+)/);
                  if (!numberMatch || !numberMatch[1]) {
                    console.log(`Invalid issue reference: ${match}`);
                    continue;
                  }
                  
                  const childIssueNumber = parseInt(numberMatch[1]);
                  
                  try {
                    // å­Issueã®æƒ…å ±ã‚’å–å¾—
                    const childIssue = await github.rest.issues.get({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: childIssueNumber
                    });
                    
                    if (childIssue.data.state === 'open') {
                      console.log(`Child issue #${childIssueNumber} is still open.`);
                      allClosed = false;
                    } else {
                      console.log(`Child issue #${childIssueNumber} is closed.`);
                      closedIssues.push(childIssueNumber);
                    }
                  } catch (error) {
                    console.log(`Error getting child issue #${childIssueNumber}: ${error.message}`);
                    // å­IssueãŒå­˜åœ¨ã—ãªã„å ´åˆã§ã‚‚å‡¦ç†ã‚’ç¶šè¡Œ
                  }
                }
                
                // ã™ã¹ã¦ã®å­IssueãŒã‚¯ãƒ­ãƒ¼ã‚ºã•ã‚Œã¦ã„ã‚Œã°è¦ªIssueã‚‚ã‚¯ãƒ­ãƒ¼ã‚º
                if (allClosed && closedIssues.length > 0) {
                  console.log(`All child issues for #${parentIssueNumber} are closed. Closing parent issue.`);
                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: parentIssueNumber,
                    state: 'closed'
                  });
                  
                  // è¦ªIssueã«ã‚³ãƒ¡ãƒ³ãƒˆã‚’è¿½åŠ 
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: parentIssueNumber,
                    body: `ğŸ‰ ã™ã¹ã¦ã®å­Issueï¼ˆ#${closedIssues.join(', #')}ï¼‰ãŒå®Œäº†ã—ãŸãŸã‚ã€ã“ã®Issueã‚’è‡ªå‹•çš„ã«ã‚¯ãƒ­ãƒ¼ã‚ºã—ã¾ã—ãŸã€‚`
                  });
                } else {
                  console.log(`Not all child issues for #${parentIssueNumber} are closed yet.`);
                }
              } catch (error) {
                console.log(`Error processing parent issue #${parentIssueNumber}: ${error.message}`);
              }
            }
